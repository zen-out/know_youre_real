const make_legit = require("make_legit")
const { see, hourglass } = require("code_clarity")
const { upset } = require("whats_wrong")
const { cleanPostObject } = require("./cleanPostObject")
const { callbacks } = require("./data.js")
const { getObject } = require("./getObject")
const { getForeignTables } = require("./getInfo")
const { tableColValCount } = require("./counts")
const { cleanUpdateObject } = require("./cleanUpdateObject")
const knex = require("knex")({
    client: "postgresql",
    connection: {
        database: "optee3",
        user: "postgres",
        password: "postgres",
    }
})

/**
 * @example
 *  let testPost = await post(knex, "hourglass", { start: "2011-02-02" }, callbacks)
 * @author zen-out
 * @date 2022-03-11
 * @param {any} knex
 * @param {any}  table
 * @param {any}  object
 * @param {any}  callbacks
 * @returns {any}
 */
async function post(knex, table, object, callbacks) {
    try {
        let getCleanObject = await cleanPostObject(knex, table, object, callbacks)
        let query = await knex(table).returning("*").insert(getCleanObject)
        let objectify = getObject(query)
        let final = make_legit.trimObj(objectify)
        return final;
    } catch (error) {
        return upset("not able to post" + error, "effective_knex, post one", "should be able to return an object")
    }
}

/**
 * @example 
 *  let testUpdate = await update(knex, "hourglass", testPost.id, { start: "2012-02-02" }, callbacks)
 * @author zen-out
 * @date 2022-03-11
 * @param {any} knex
 * @param {any}  table
 * @param {any}  id
 * @param {any}  object
 * @param {any}  callbacks
 * @returns {any}
 */
async function update(knex, table, id, object, callbacks) {
    try {
        let getUpdateObject = await cleanUpdateObject(knex, table, id, object, callbacks)
        let query = await knex(table).returning("*").where({ id: id }).update(getUpdateObject)
        let objectify = getObject(query)
        let final = make_legit.trimObj(objectify)
        return final;
    } catch (error) {
        return upset("not able to update" + error, "effective_knex, update one", "should be able to return an object")
    }
}

/**
 * updateOne
 * @author zen-out
 * @date 2022-03-16
 * @param {any} knex
 * @param {any}  table
 * @param {any}  id
 * @param {any}  key
 * @param {any}  value
 * @returns {object}
 */
async function updateOne(knex, table, id, key, value) {
    try {
        let obj = {}
        obj[key] = value;
        let getUpdateObject = await cleanUpdateObject(knex, table, id, obj)
        let query = await knex(table).returning("*").where({ id: id }).update(getUpdateObject)
        let objectify = getObject(query)
        let final = make_legit.trimObj(objectify)
        return final;
    } catch (error) {
        return upset("not able to update" + error, "effective_knex, update one", "should be able to return an object")
    }
}

async function testPostAndUpdate() {
    let testPost = await post(knex, "hourglass", { start: "2011-02-02" }, callbacks)
    console.log(testPost)
    let testUpdate = await update(knex, "hourglass", testPost.id, { start: "2012-02-02" }, callbacks)
    see.done("ðŸš€ ~ file: basic.js ~ line 32 ~ testPostAndUpdate ~ testUpdate", testUpdate)
    let testOneUpdate = await updateOne(knex, "hourglass", 344, "public", true)
    console.log("ðŸš€ ~ file: basic.js ~ line 98 ~ testPostAndUpdate ~ testOneUpdate", testOneUpdate)
}
// testPostAndUpdate()




module.exports = { post, update, updateOne, testPostAndUpdate };